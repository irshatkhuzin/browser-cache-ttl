{"version":3,"sources":["../src/index.ts","../src/core/MemoryAdapter.ts","../src/core/LocalStorageAdapter.ts","../src/core/CacheManager.ts"],"sourcesContent":["export { CacheManager } from './core/CacheManager';\nexport { MemoryAdapter } from './core/MemoryAdapter';\nexport { LocalStorageAdapter } from './core/LocalStorageAdapter';\nexport type { CacheEntry } from './types';\n","import {CacheAdapter, CacheEntry} from \"../types\";\r\n\r\nexport class MemoryAdapter implements CacheAdapter {\r\n    private store = new Map<string, CacheEntry<any>>();\r\n\r\n    private get timeSecond(){\r\n        return Math.floor(Date.now() / 1000)\r\n    }\r\n\r\n    set<T>(key: string, value: T, ttlSec?: number): void {\r\n        const expiresAt = ttlSec ? this.timeSecond + ttlSec : undefined;\r\n        this.store.set(key, { value, expiresAt });\r\n    }\r\n\r\n    get<T>(key: string): T | null {\r\n        const entry = this.store.get(key);\r\n        if (!entry) return null;\r\n        if (entry.expiresAt && entry.expiresAt < this.timeSecond) {\r\n            this.store.delete(key);\r\n            return null;\r\n        }\r\n        return entry.value;\r\n    }\r\n\r\n    delete(key: string): void {\r\n        this.store.delete(key);\r\n    }\r\n\r\n    has(key: string): boolean {\r\n        const entry = this.store.get(key);\r\n        if (!entry) return false;\r\n\r\n        if (entry.expiresAt && entry.expiresAt < this.timeSecond) {\r\n            this.store.delete(key);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    cleanupExpired() {\r\n        for (const [key, entry] of this.store.entries()) {\r\n            if (entry.expiresAt && entry.expiresAt < this.timeSecond) {\r\n                this.store.delete(key);\r\n            }\r\n        }\r\n    }\r\n    destroy(): void {}\r\n}\r\n","import { CacheAdapter, CacheEntry } from '../types';\r\n\r\n/**\r\n * Adapter for storing data in localStorage with TTL support.\r\n */\r\nexport class LocalStorageAdapter implements CacheAdapter {\r\n    private get timeSecond(){\r\n        return Math.floor(Date.now() / 1000)\r\n    }\r\n\r\n    /**\r\n     * Stores a value in localStorage with a TTL.\r\n     * @param key The key to store.\r\n     * @param value The value to store.\r\n     * @param ttlSec The time to live in seconds.\r\n     */\r\n    set<T>(key: string, value: T, ttlSec?: number): void {\r\n        const expiresAt = ttlSec ? this.timeSecond + ttlSec : undefined;\r\n\r\n        const entry: CacheEntry<T> = {\r\n            value,\r\n            expiresAt,\r\n        };\r\n\r\n        try {\r\n            const serialized = JSON.stringify(entry);\r\n            localStorage.setItem(key, serialized);\r\n        } catch (error) {}\r\n    }\r\n\r\n    /**\r\n     * Gets the value from localStorage if it is not expired.\r\n     * @param key The storage key.\r\n     * @returns The value or null.\r\n     */\r\n    get<T>(key: string): T | null {\r\n        const raw = localStorage.getItem(key);\r\n        if (!raw) return null;\r\n\r\n        try {\r\n            const entry: CacheEntry<T> = JSON.parse(raw);\r\n\r\n            if (entry.expiresAt && entry.expiresAt < this.timeSecond) {\r\n                this.delete(key);\r\n                return null;\r\n            }\r\n\r\n            return entry.value;\r\n        } catch (error) {\r\n            console.warn(`[LocalStorageAdapter] Ошибка парсинга для ключа \"${key}\":`, error);\r\n            this.delete(key);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a value from localStorage.\r\n     * @param key Storage key.\r\n     */\r\n    delete(key: string): void {\r\n        localStorage.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Checks for the presence of an unexpired value by key.\r\n     * @param key Key.\r\n     * @returns true if the value exists and has not expired.\r\n     */\r\n    has(key: string): boolean {\r\n        const raw = localStorage.getItem(key);\r\n        if (!raw) return false;\r\n\r\n        try {\r\n            const entry: CacheEntry<unknown> = JSON.parse(raw);\r\n\r\n            if (entry.expiresAt && entry.expiresAt < this.timeSecond) {\r\n                this.delete(key);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        } catch {\r\n            this.delete(key);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    cleanupExpired(): void {\r\n        for (let i = localStorage.length - 1; i >= 0; i--) {\r\n            const key = localStorage.key(i);\r\n            if (!key) continue;\r\n\r\n            const raw = localStorage.getItem(key);\r\n            if (!raw) continue;\r\n\r\n            try {\r\n                const entry = JSON.parse(raw);\r\n                if (entry.expiresAt && entry.expiresAt < this.timeSecond) {\r\n                    localStorage.removeItem(key);\r\n                }\r\n            } catch {\r\n                localStorage.removeItem(key);\r\n            }\r\n        }\r\n    }\r\n\r\n    destroy(): void {}\r\n}\r\n","import {CacheAdapter} from \"../types\";\r\nimport {MemoryAdapter} from \"./MemoryAdapter\";\r\nimport {LocalStorageAdapter} from \"./LocalStorageAdapter\";\r\n\r\nexport class CacheManager {\r\n    private adapter: CacheAdapter;\r\n    private cleanupIntervalId: ReturnType<typeof setInterval> | null = null;\r\n    private cleanupIntervalMs = 60 * 1000; // по умолчанию 1 минута\r\n\r\n    constructor(options?: { cleanupIntervalMs?: number }) {\r\n        this.adapter = CacheManager.checkLocalStorage()\r\n            ? new LocalStorageAdapter()\r\n            : new MemoryAdapter();\r\n\r\n        if (options?.cleanupIntervalMs) {\r\n            this.cleanupIntervalMs = options.cleanupIntervalMs;\r\n        }\r\n\r\n        this.startCleanupTask();\r\n    }\r\n\r\n    private startCleanupTask(): void {\r\n        this.cleanupIntervalId = setInterval(() => {\r\n            this.adapter.cleanupExpired();\r\n        }, this.cleanupIntervalMs);\r\n    }\r\n\r\n    static checkLocalStorage(): boolean {\r\n        if (typeof localStorage === 'undefined') return false;\r\n        try {\r\n            const testKey = '__test__';\r\n            localStorage.setItem(testKey, '1');\r\n            localStorage.removeItem(testKey);\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    set<T>(key: string, value: T, ttlSecond?: number): void {\r\n        this.adapter.set(key, value, ttlSecond);\r\n    }\r\n\r\n    get<T>(key: string): T | null {\r\n        return this.adapter.get(key);\r\n    }\r\n\r\n    delete(key: string): void {\r\n        this.adapter.delete(key);\r\n    }\r\n\r\n    has(key: string): boolean {\r\n        return this.adapter.has(key);\r\n    }\r\n\r\n    destroy(): void {\r\n        if (this.cleanupIntervalId) {\r\n            clearInterval(this.cleanupIntervalId);\r\n            this.cleanupIntervalId = null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","names":["index_exports","__export","CacheManager","LocalStorageAdapter","MemoryAdapter","__toCommonJS","MemoryAdapter","key","value","ttlSec","expiresAt","entry","LocalStorageAdapter","key","value","ttlSec","expiresAt","entry","serialized","error","raw","e","i","CacheManager","_CacheManager","options","LocalStorageAdapter","MemoryAdapter","testKey","key","value","ttlSecond"]}